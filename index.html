<!DOCTYPE html>
<html lang="it">
<head>
  <base href="/cie_def/">

  <meta charset="UTF-8">
  <meta content="IE=Edge" http-equiv="X-UA-Compatible">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0">
  <meta name="description" content="Rinnova la tua Carta d'Identit√† Elettronica (CIE) in pochi passi.">
  <meta name="theme-color" content="#0066CC">

  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Rinnovo CIE">
  <link rel="apple-touch-icon" href="icons/Icon-192.png">

  <link rel="icon" type="image/png" href="favicon.png"/>

  <title>Rinnovo CIE</title>
  <link rel="manifest" href="manifest.json">
</head>

<body>
  <!-- Cargar Tesseract ANTES de Flutter -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
  
  <script>
  console.log('üîß Iniciando carga de scanMRZ...');
  
  // Esperar a que Tesseract se cargue
  (function waitForTesseract() {
    if (typeof Tesseract !== 'undefined') {
      console.log('‚úÖ Tesseract cargado');
      initScanMRZ();
    } else {
      console.log('‚è≥ Esperando Tesseract...');
      setTimeout(waitForTesseract, 100);
    }
  })();
  
  function initScanMRZ() {
    window.scanMRZ = async function(base64Image) {
      console.log('üîç Iniciando escaneo MRZ...');
      
      try {
        const img = await base64ToImage(base64Image);
        console.log(`üìê Imagen cargada: ${img.width}x${img.height}`);
        
        const processedImage = preprocessForMRZ(img);
        
        console.log('ü§ñ Ejecutando Tesseract OCR...');
        const { data: { text } } = await Tesseract.recognize(
          processedImage,
          'eng',
          {
            logger: m => console.log('üìä OCR:', m.status, m.progress),
            tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789<',
          }
        );
        
        console.log('üìù Texto detectado:', text);
        
        const mrzLines = extractMRZLines(text);
        
        if (mrzLines.length >= 3) {
          const mrzText = mrzLines.join('\n');
          console.log('‚úÖ MRZ encontrado:', mrzText);
          return mrzText;
        } else {
          console.warn('‚ö†Ô∏è No se encontraron 3 l√≠neas MRZ v√°lidas');
          return null;
        }
        
      } catch (error) {
        console.error('‚ùå Error en scanMRZ:', error);
        return null;
      }
    };

    function preprocessForMRZ(img) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      // RECORTAR: Usar el 35% inferior de la imagen (zona MRZ + margen)
      const cropStartY = Math.floor(img.height * 0.65);  // Comenzar en el 65% (antes era 70%)
      const cropHeight = img.height - cropStartY;         // Hasta el final
      
      // Escalar para mejor OCR (m√≠nimo 300 DPI equivalente)
      const targetWidth = Math.max(img.width, 2000);
      const scale = targetWidth / img.width;
      
      canvas.width = img.width * scale;
      canvas.height = cropHeight * scale;
      
      // Dibujar SOLO la zona inferior recortada
      ctx.drawImage(
        img,
        0, cropStartY,                    // Source: inicio X, inicio Y
        img.width, cropHeight,            // Source: ancho, alto
        0, 0,                             // Dest: inicio X, inicio Y
        canvas.width, canvas.height       // Dest: ancho, alto
      );
      
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      
      // Convertir a escala de grises con MUCHO contraste
      for (let i = 0; i < data.length; i += 4) {
        const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
        
        // Aumentar contraste agresivamente
        const contrast = 2.0;  // Factor de contraste muy alto
        const adjusted = ((gray - 128) * contrast) + 128;
        
        // Threshold m√°s agresivo
        const threshold = adjusted > 150 ? 255 : 0;
        
        data[i] = threshold;
        data[i + 1] = threshold;
        data[i + 2] = threshold;
      }
      
      ctx.putImageData(imageData, 0, 0);
      
      console.log('üñºÔ∏è Imagen preprocesada (recortada):', canvas.width, 'x', canvas.height);
      console.log('üìê Recorte: desde Y=' + cropStartY + ' (70% de ' + img.height + ')');
      return canvas;
    }

    function extractMRZLines(text) {
      console.log('üîç Texto raw recibido:', text);
      
      const lines = text
        .split('\n')
        .map(line => line.trim().toUpperCase())
        .filter(line => line.length > 0);
      
      console.log('üìã L√≠neas encontradas:', lines.length);
      
      // SIMPLE: Tomar las 3 √öLTIMAS l√≠neas
      const mrzLines = [];
      
      if (lines.length >= 3) {
        // Tomar las √∫ltimas 3 l√≠neas
        const lastThree = lines.slice(-3);
        
        for (let i = 0; i < lastThree.length; i++) {
          const line = lastThree[i];
          
          // Limpiar caracteres - SOLO quitar inv√°lidos, NO convertir letras a n√∫meros todav√≠a
          let cleaned = line.replace(/[^A-Z0-9<]/g, '');  // Solo alfanum√©ricos y <
          
          console.log(`  L√≠nea ${i+1}: "${cleaned}" (${cleaned.length} chars)`);
          
          // NO normalizar, dejar el largo que venga del OCR
          mrzLines.push(cleaned);
        }
      }
      
      // POST-PROCESAMIENTO: Corregir errores comunes de OCR
      if (mrzLines.length === 3) {
        console.log('üîß Antes de correcciones:');
        console.log('  L1:', mrzLines[0]);
        console.log('  L2:', mrzLines[1]);
        console.log('  L3:', mrzLines[2]);
        
        mrzLines[0] = fixMRZLine1(mrzLines[0]);
        mrzLines[1] = fixMRZLine2(mrzLines[1]);
        mrzLines[2] = fixMRZLine3(mrzLines[2]);
        
        console.log('üîß Despu√©s de correcciones:');
        console.log('  L1:', mrzLines[0]);
        console.log('  L2:', mrzLines[1]);
        console.log('  L3:', mrzLines[2]);
      }
      
      console.log(`üìä Total l√≠neas MRZ encontradas: ${mrzLines.length}`);
      return mrzLines;
    }
    
    // Correcci√≥n L√≠nea 1: IDITA<<<<<<<<<<<<<<<<<<<<<<<<<<
    function fixMRZLine1(line) {
      let fixed = line;
      
      // K y L son casi siempre < en MRZ
      fixed = fixed.replace(/K/g, '<');
      fixed = fixed.replace(/L/g, '<');
      
      // Corregir inicio com√∫n: debe empezar con IDITA
      // Patrones comunes: 1D1TA, ID1TA, 1DITA
      if (fixed.startsWith('1D1TA')) {
        fixed = 'IDITA' + fixed.substring(5);
      } else if (fixed.startsWith('ID1TA')) {
        fixed = 'IDITA' + fixed.substring(5);
      } else if (fixed.startsWith('1DITA')) {
        fixed = 'IDITA' + fixed.substring(5);
      }
      
      return fixed;
    }
    
    // Correcci√≥n L√≠nea 2: 6412308F2212304ITA<<<<<<<<<0
    function fixMRZLine2(line) {
      let fixed = line;
      
      // SOLO K y L son <, NO tocar n√∫meros
      fixed = fixed.replace(/K/g, '<');
      fixed = fixed.replace(/L/g, '<');
      
      // NO hacer m√°s correcciones aqu√≠, los n√∫meros deben quedarse como est√°n
      
      return fixed;
    }
    
    // Correcci√≥n L√≠nea 3: ROSSI<<MARIO<<<<<<<<<<<<<<<<
    function fixMRZLine3(line) {
      let fixed = line;
      
      // K y L son <
      fixed = fixed.replace(/K/g, '<');
      fixed = fixed.replace(/L/g, '<');
      
      // En nombres italianos, corregir n√∫meros comunes:
      // 0 -> O, 5 -> S, 1 -> I en contexto de letras
      // Solo en los primeros 20 caracteres (zona de nombre/apellido)
      const namePart = fixed.substring(0, 20);
      const restPart = fixed.substring(20);
      
      let correctedName = namePart
        .replace(/0/g, 'O')  // 0 -> O en nombres
        .replace(/5/g, 'S')  // 5 -> S en nombres
        .replace(/1/g, 'I'); // 1 -> I en nombres
      
      fixed = correctedName + restPart;
      
      return fixed;
    }

    function base64ToImage(base64) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = 'data:image/jpeg;base64,' + base64;
      });
    }
    
    console.log('‚úÖ scanMRZ definido correctamente');
  }
  </script>

  <script>
    window.addEventListener('load', function () {
      if ('serviceWorker' in navigator) {
        navigator.serviceWorker.getRegistrations().then(function(registrations) {
          for (let reg of registrations) { reg.unregister(); }
        });
      }
    });
  </script>
  
  <script src="flutter_bootstrap.js" async></script>
</body>
</html>
